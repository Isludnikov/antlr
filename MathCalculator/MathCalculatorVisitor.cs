using Antlr.Expression;
using MathCalculatorAutogenerated;
using System.Globalization;

namespace Antlr.MathCalculator;

internal class MathCalculatorVisitor : MathCalculatorBaseVisitor<decimal>
{
    private readonly IDictionary<string, decimal> variables;
    private readonly IMathCalculatorFunctions functions;

    public MathCalculatorVisitor(IDictionary<string, decimal> variables, IMathCalculatorFunctions functions)
    {
        this.variables = variables;
        this.functions = functions;
    }

    public override decimal VisitMultiplyingExpression(MathCalculatorParser.MultiplyingExpressionContext context)
    {
        if (context.ChildCount == 1)
            return Visit(context.children[0]);
        var v1 = Visit(context.children[0]);
        var v2 = Visit(context.children[2]);
        var op = context.MULDIVMODOP()[0].Symbol.Text;
        return op switch
        {
            "*" => v1 * v2,
            "/" => v1 / v2,
            "MOD" => v1 % v2,
            _ => throw new ExpressionException($"Bad op [{op}]")
        };
    }

    public override decimal VisitNumericExpression(MathCalculatorParser.NumericExpressionContext context)
    {
        if (context.ChildCount == 1)
            return Visit(context.children[0]);
        var v1 = Visit(context.children[0]);
        var v2 = Visit(context.children[2]);
        var op = context.PLUSMINUSOP()[0].Symbol.Text;
        return op switch
        {
            "+" => v1 + v2,
            "-" => v1 - v2,
            _ => throw new ExpressionException($"Bad op [{op}]")
        };
    }

    public override decimal VisitPowExpression(MathCalculatorParser.PowExpressionContext context)
    {
        if (context.ChildCount == 1) return Visit(context.children[0]);
        var v1 = Visit(context.children[0]);
        var v2 = Visit(context.children[2]);
        return (decimal)Math.Pow((double)v1, (double)v2);
    }

    public override decimal VisitScalarVariable(MathCalculatorParser.ScalarVariableContext context)
    {
        var name = context.GetText();
        if (!variables.ContainsKey(name)) throw new Exception($"Bad variable name [{name}]");
        return variables[name];
    }

    public override decimal VisitFunc(MathCalculatorParser.FuncContext context)
    {
        var funcName = context.funcName().GetText();

        var funcParams = new Dictionary<string, decimal>();
        if (context.parameters() != null)
        {
            var parameters = context.parameters().parameter();
            var counter = 0;
            foreach (var parameter in parameters)
            {
                var paramName = parameter.paramName() != null ? parameter.paramName().GetText() : counter.ToString();


                funcParams[paramName] = Visit(parameter.paramValue());

                ++counter;
            }
        }
        return functions.Call(funcName, funcParams);
    }

    public override decimal VisitScientific(MathCalculatorParser.ScientificContext context)
    {
        var text = context.GetText();
        var result = decimal.TryParse(text, CultureInfo.InvariantCulture, out var d);
        return result
            ? d
            : throw new ExpressionException($"Bad input [{text}] awaiting decimal");
    }

    public override decimal VisitGroup(MathCalculatorParser.GroupContext context)
    {
        return Visit(context.GetChild(1));
    }

    public override decimal VisitUnaryMinus(MathCalculatorParser.UnaryMinusContext context)
    {
        if (context.ChildCount == 1) return Visit(context.GetChild(0));
        return -Visit(context.GetChild(1));
    }
}